; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	E:\C ++\C++Projects\console\likeEatSnack\likeEatSnack\snack.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?outputData@@3PAEA				; outputData
PUBLIC	?pivot@@3PAUNode@@A				; pivot
PUBLIC	?graph@@3PAY07EA				; graph
PUBLIC	?isLose@@3DA					; isLose
PUBLIC	?isWin@@3DA					; isWin
PUBLIC	?len@@3EA					; len
PUBLIC	?head@@3PAUNode@@A				; head
PUBLIC	?heap@@3UHeap@@A				; heap
PUBLIC	?food@@3PAUNode@@A				; food
PUBLIC	?dirs@@3PAUDir@@A				; dirs
PUBLIC	?idir@@3EA					; idir
PUBLIC	?winLen@@3EA					; winLen
PUBLIC	?c@@3HA						; c
_BSS	SEGMENT
?outputData@@3PAEA DB 08H DUP (?)			; outputData
?pivot@@3PAUNode@@A DD 01H DUP (?)			; pivot
?graph@@3PAY07EA DB 040H DUP (?)			; graph
?isLose@@3DA DB	01H DUP (?)				; isLose
	ALIGN	4

?isWin@@3DA DB	01H DUP (?)				; isWin
	ALIGN	4

?len@@3EA DB	01H DUP (?)				; len
	ALIGN	4

?head@@3PAUNode@@A DD 01H DUP (?)			; head
?heap@@3UHeap@@A DB 0208H DUP (?)			; heap
?food@@3PAUNode@@A DD 01H DUP (?)			; food
_BSS	ENDS
_DATA	SEGMENT
?dirs@@3PAUDir@@A DB 00H				; dirs
	DB	00H
	DB	0ffH
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	0ffH
?idir@@3EA DB	03H					; idir
?winLen@@3EA DB	012H					; winLen
?c@@3HA	DD	07H					; c
_DATA	ENDS
PUBLIC	?myalloc@@YAPAXG@Z				; myalloc
; Function compile flags: /Odtp
_TEXT	SEGMENT
_num$ = 8						; size = 2
?myalloc@@YAPAXG@Z PROC					; myalloc
	push	ebp
	mov	ebp, esp
	movzx	eax, WORD PTR ?heap@@3UHeap@@A+512
	add	eax, OFFSET ?heap@@3UHeap@@A		; heap
	mov	DWORD PTR ?heap@@3UHeap@@A+516, eax
	movzx	ecx, WORD PTR _num$[ebp]
	movzx	edx, WORD PTR ?heap@@3UHeap@@A+512
	add	edx, ecx
	mov	WORD PTR ?heap@@3UHeap@@A+512, dx
	mov	eax, DWORD PTR ?heap@@3UHeap@@A+516
	pop	ebp
	ret	0
?myalloc@@YAPAXG@Z ENDP					; myalloc
_TEXT	ENDS
PUBLIC	?newNode@@YAPAUNode@@EEPAU1@@Z			; newNode
; Function compile flags: /Odtp
_TEXT	SEGMENT
_node$ = -4						; size = 4
_tx$ = 8						; size = 1
_ty$ = 12						; size = 1
_p$ = 16						; size = 4
?newNode@@YAPAUNode@@EEPAU1@@Z PROC			; newNode
	push	ebp
	mov	ebp, esp
	push	ecx
	push	8
	call	?myalloc@@YAPAXG@Z			; myalloc
	add	esp, 4
	mov	DWORD PTR _node$[ebp], eax
	mov	eax, DWORD PTR _node$[ebp]
	mov	cl, BYTE PTR _tx$[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _node$[ebp]
	mov	al, BYTE PTR _ty$[ebp]
	mov	BYTE PTR [edx+1], al
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR _node$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?newNode@@YAPAUNode@@EEPAU1@@Z ENDP			; newNode
_TEXT	ENDS
PUBLIC	?getRand@@YAHXZ					; getRand
; Function compile flags: /Odtp
_TEXT	SEGMENT
?getRand@@YAHXZ PROC					; getRand
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ?c@@3HA			; c
	imul	eax, DWORD PTR ?an@@3HA			; an
	add	eax, 1
	cdq
	mov	ecx, 65535				; 0000ffffH
	idiv	ecx
	mov	DWORD PTR ?an@@3HA, edx			; an
	mov	eax, DWORD PTR ?an@@3HA			; an
	pop	ebp
	ret	0
?getRand@@YAHXZ ENDP					; getRand
_TEXT	ENDS
PUBLIC	?setSeed@@YAXH@Z				; setSeed
; Function compile flags: /Odtp
_TEXT	SEGMENT
_t$ = -4						; size = 4
_k$ = 8							; size = 4
?setSeed@@YAXH@Z PROC					; setSeed
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	eax, DWORD PTR _k$[ebp]
	mov	DWORD PTR _t$[ebp], eax
	cmp	DWORD PTR _k$[ebp], 6
	je	SHORT $LN4@setSeed
	mov	ecx, DWORD PTR _k$[ebp]
	lea	edx, DWORD PTR [ecx+ecx+1]
	mov	DWORD PTR _k$[ebp], edx
$LN4@setSeed:
	mov	eax, DWORD PTR _k$[ebp]
	and	eax, -2147483641			; 80000007H
	jns	SHORT $LN7@setSeed
	dec	eax
	or	eax, -8					; fffffff8H
	inc	eax
$LN7@setSeed:
	mov	DWORD PTR _k$[ebp], eax
	cmp	DWORD PTR _k$[ebp], 1
	jne	SHORT $LN3@setSeed
	mov	DWORD PTR _k$[ebp], 7
$LN3@setSeed:
	mov	ecx, DWORD PTR _k$[ebp]
	mov	DWORD PTR ?c@@3HA, ecx			; c
	mov	edx, DWORD PTR ?c@@3HA			; c
	mov	DWORD PTR ?an@@3HA, edx			; an
$LN2@setSeed:
	mov	eax, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _t$[ebp], ecx
	test	eax, eax
	je	SHORT $LN5@setSeed
	call	?getRand@@YAHXZ				; getRand
	jmp	SHORT $LN2@setSeed
$LN5@setSeed:
	mov	esp, ebp
	pop	ebp
	ret	0
?setSeed@@YAXH@Z ENDP					; setSeed
_TEXT	ENDS
PUBLIC	?init@@YAXXZ					; init
; Function compile flags: /Odtp
_TEXT	SEGMENT
?init@@YAXXZ PROC					; init
	push	ebp
	mov	ebp, esp
	push	0
	push	1
	push	2
	call	?newNode@@YAPAUNode@@EEPAU1@@Z		; newNode
	add	esp, 12					; 0000000cH
	mov	DWORD PTR ?head@@3PAUNode@@A, eax	; head
	push	0
	push	0
	call	?newNode@@YAPAUNode@@EEPAU1@@Z		; newNode
	add	esp, 12					; 0000000cH
	mov	DWORD PTR ?food@@3PAUNode@@A, eax	; food
	mov	edx, DWORD PTR ?head@@3PAUNode@@A	; head
	mov	eax, DWORD PTR [edx+4]
	push	eax
	push	0
	push	0
	call	?newNode@@YAPAUNode@@EEPAU1@@Z		; newNode
	add	esp, 12					; 0000000cH
	mov	DWORD PTR ?pivot@@3PAUNode@@A, eax	; pivot
	mov	BYTE PTR ?isWin@@3DA, 0			; isWin
	mov	cl, BYTE PTR ?isWin@@3DA		; isWin
	mov	BYTE PTR ?isLose@@3DA, cl		; isLose
	pop	ebp
	ret	0
?init@@YAXXZ ENDP					; init
_TEXT	ENDS
PUBLIC	?lose@@YAXXZ					; lose
; Function compile flags: /Odtp
_TEXT	SEGMENT
?lose@@YAXXZ PROC					; lose
	push	ebp
	mov	ebp, esp
	movsx	eax, BYTE PTR ?isWin@@3DA		; isWin
	test	eax, eax
	jne	SHORT $LN2@lose
	mov	BYTE PTR ?isLose@@3DA, 1		; isLose
$LN2@lose:
	pop	ebp
	ret	0
?lose@@YAXXZ ENDP					; lose
_TEXT	ENDS
PUBLIC	?win@@YAXXZ					; win
; Function compile flags: /Odtp
_TEXT	SEGMENT
?win@@YAXXZ PROC					; win
	push	ebp
	mov	ebp, esp
	movsx	eax, BYTE PTR ?isLose@@3DA		; isLose
	test	eax, eax
	jne	SHORT $LN2@win
	mov	BYTE PTR ?isWin@@3DA, 1			; isWin
$LN2@win:
	pop	ebp
	ret	0
?win@@YAXXZ ENDP					; win
_TEXT	ENDS
PUBLIC	?createGraph@@YAXXZ				; createGraph
; Function compile flags: /Odtp
_TEXT	SEGMENT
_pg$ = -12						; size = 4
_i$ = -5						; size = 1
_p$ = -4						; size = 4
?createGraph@@YAXXZ PROC				; createGraph
	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _pg$[ebp], OFFSET ?graph@@3PAY07EA ; graph
	mov	BYTE PTR _i$[ebp], 0
	jmp	SHORT $LN6@createGrap
$LN5@createGrap:
	mov	al, BYTE PTR _i$[ebp]
	add	al, 1
	mov	BYTE PTR _i$[ebp], al
$LN6@createGrap:
	movzx	ecx, BYTE PTR _i$[ebp]
	cmp	ecx, 64					; 00000040H
	jge	SHORT $LN4@createGrap
	mov	edx, DWORD PTR _pg$[ebp]
	mov	BYTE PTR [edx], 0
	mov	eax, DWORD PTR _pg$[ebp]
	add	eax, 1
	mov	DWORD PTR _pg$[ebp], eax
	jmp	SHORT $LN5@createGrap
$LN4@createGrap:
	mov	ecx, DWORD PTR ?head@@3PAUNode@@A	; head
	mov	DWORD PTR _p$[ebp], ecx
$LN3@createGrap:
	mov	edx, DWORD PTR _p$[ebp]
	movzx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _p$[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	mov	BYTE PTR ?graph@@3PAY07EA[edx+eax*8], 1
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _p$[ebp], ecx
	mov	edx, DWORD PTR _p$[ebp]
	cmp	edx, DWORD PTR ?head@@3PAUNode@@A	; head
	jne	SHORT $LN3@createGrap
	mov	eax, DWORD PTR ?food@@3PAUNode@@A	; food
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR ?food@@3PAUNode@@A	; food
	movzx	eax, BYTE PTR [edx+1]
	mov	BYTE PTR ?graph@@3PAY07EA[eax+ecx*8], 2
	mov	esp, ebp
	pop	ebp
	ret	0
?createGraph@@YAXXZ ENDP				; createGraph
_TEXT	ENDS
PUBLIC	?move@@YAXE@Z					; move
; Function compile flags: /Odtp
_TEXT	SEGMENT
_ipg$2662 = -17						; size = 1
_pg$2661 = -16						; size = 4
_index$2660 = -9					; size = 1
_dir$ = -8						; size = 2
_p$ = -4						; size = 4
_tdir$ = 8						; size = 1
?move@@YAXE@Z PROC					; move
	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	movzx	eax, BYTE PTR _tdir$[ebp]
	test	eax, eax
	jle	SHORT $LN13@move
	movzx	ecx, BYTE PTR _tdir$[ebp]
	cmp	ecx, 5
	jl	SHORT $LN14@move
$LN13@move:
	mov	dl, BYTE PTR ?idir@@3EA			; idir
	mov	BYTE PTR _tdir$[ebp], dl
$LN14@move:
	movzx	eax, BYTE PTR _tdir$[ebp]
	mov	cx, WORD PTR ?dirs@@3PAUDir@@A[eax*2]
	mov	WORD PTR _dir$[ebp], cx
	mov	edx, DWORD PTR ?head@@3PAUNode@@A	; head
	mov	DWORD PTR _p$[ebp], edx
	mov	eax, DWORD PTR ?head@@3PAUNode@@A	; head
	movzx	ecx, BYTE PTR [eax]
	movzx	edx, BYTE PTR _dir$[ebp]
	add	ecx, edx
	and	ecx, -2147483641			; 80000007H
	jns	SHORT $LN17@move
	dec	ecx
	or	ecx, -8					; fffffff8H
	inc	ecx
$LN17@move:
	mov	eax, DWORD PTR ?pivot@@3PAUNode@@A	; pivot
	mov	BYTE PTR [eax], cl
	mov	ecx, DWORD PTR ?head@@3PAUNode@@A	; head
	movzx	edx, BYTE PTR [ecx+1]
	movzx	eax, BYTE PTR _dir$[ebp+1]
	add	edx, eax
	and	edx, -2147483641			; 80000007H
	jns	SHORT $LN18@move
	dec	edx
	or	edx, -8					; fffffff8H
	inc	edx
$LN18@move:
	mov	ecx, DWORD PTR ?pivot@@3PAUNode@@A	; pivot
	mov	BYTE PTR [ecx+1], dl
	mov	edx, DWORD PTR ?food@@3PAUNode@@A	; food
	movzx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR ?pivot@@3PAUNode@@A	; pivot
	movzx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	$LN12@move
	mov	eax, DWORD PTR ?food@@3PAUNode@@A	; food
	movzx	ecx, BYTE PTR [eax+1]
	mov	edx, DWORD PTR ?pivot@@3PAUNode@@A	; pivot
	movzx	eax, BYTE PTR [edx+1]
	cmp	ecx, eax
	jne	$LN12@move
	mov	ecx, DWORD PTR ?head@@3PAUNode@@A	; head
	mov	edx, DWORD PTR ?pivot@@3PAUNode@@A	; pivot
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR ?pivot@@3PAUNode@@A	; pivot
	mov	DWORD PTR ?head@@3PAUNode@@A, eax	; head
	mov	cl, BYTE PTR ?len@@3EA			; len
	add	cl, 1
	mov	BYTE PTR ?len@@3EA, cl			; len
	movzx	edx, BYTE PTR ?len@@3EA			; len
	movzx	eax, BYTE PTR ?winLen@@3EA		; winLen
	cmp	edx, eax
	jl	SHORT $LN11@move
	call	?win@@YAXXZ				; win
$LN11@move:
	mov	ecx, DWORD PTR ?head@@3PAUNode@@A	; head
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	push	0
	push	0
	call	?newNode@@YAPAUNode@@EEPAU1@@Z		; newNode
	add	esp, 12					; 0000000cH
	mov	DWORD PTR ?pivot@@3PAUNode@@A, eax	; pivot
	call	?getRand@@YAHXZ				; getRand
	movzx	ecx, BYTE PTR ?len@@3EA			; len
	mov	esi, 64					; 00000040H
	sub	esi, ecx
	cdq
	idiv	esi
	mov	BYTE PTR _index$2660[ebp], dl
	mov	dl, BYTE PTR _index$2660[ebp]
	add	dl, 1
	mov	BYTE PTR _index$2660[ebp], dl
	call	?createGraph@@YAXXZ			; createGraph
	mov	DWORD PTR _pg$2661[ebp], OFFSET ?graph@@3PAY07EA ; graph
	mov	BYTE PTR _ipg$2662[ebp], 0
$LN10@move:
	movzx	eax, BYTE PTR _index$2660[ebp]
	test	eax, eax
	je	SHORT $LN9@move
	movzx	ecx, BYTE PTR _ipg$2662[ebp]
	mov	edx, DWORD PTR _pg$2661[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	cl, BYTE PTR _ipg$2662[ebp]
	add	cl, 1
	mov	BYTE PTR _ipg$2662[ebp], cl
	test	eax, eax
	jne	SHORT $LN8@move
	mov	dl, BYTE PTR _index$2660[ebp]
	sub	dl, 1
	mov	BYTE PTR _index$2660[ebp], dl
$LN8@move:
	jmp	SHORT $LN10@move
$LN9@move:
	mov	al, BYTE PTR _ipg$2662[ebp]
	sub	al, 1
	mov	BYTE PTR _ipg$2662[ebp], al
	movzx	eax, BYTE PTR _ipg$2662[ebp]
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	mov	ecx, DWORD PTR ?food@@3PAUNode@@A	; food
	mov	BYTE PTR [ecx], al
	movzx	edx, BYTE PTR _ipg$2662[ebp]
	and	edx, -2147483641			; 80000007H
	jns	SHORT $LN19@move
	dec	edx
	or	edx, -8					; fffffff8H
	inc	edx
$LN19@move:
	mov	eax, DWORD PTR ?food@@3PAUNode@@A	; food
	mov	BYTE PTR [eax+1], dl
	jmp	$LN15@move
	jmp	$LN15@move
$LN12@move:
	mov	ecx, DWORD PTR ?head@@3PAUNode@@A	; head
	mov	DWORD PTR _p$[ebp], ecx
$LN6@move:
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _p$[ebp], eax
	mov	ecx, DWORD PTR _p$[ebp]
	cmp	ecx, DWORD PTR ?head@@3PAUNode@@A	; head
	je	SHORT $LN5@move
	mov	edx, DWORD PTR _p$[ebp]
	movzx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR ?pivot@@3PAUNode@@A	; pivot
	movzx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN4@move
	mov	eax, DWORD PTR _p$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	mov	edx, DWORD PTR ?pivot@@3PAUNode@@A	; pivot
	movzx	eax, BYTE PTR [edx+1]
	cmp	ecx, eax
	jne	SHORT $LN4@move
	jmp	SHORT $LN5@move
$LN4@move:
	jmp	SHORT $LN6@move
$LN5@move:
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR ?head@@3PAUNode@@A	; head
	jne	SHORT $LN3@move
	mov	al, BYTE PTR ?idir@@3EA			; idir
	mov	BYTE PTR _tdir$[ebp], al
	movzx	ecx, BYTE PTR _tdir$[ebp]
	mov	dx, WORD PTR ?dirs@@3PAUDir@@A[ecx*2]
	mov	WORD PTR _dir$[ebp], dx
	mov	eax, DWORD PTR ?head@@3PAUNode@@A	; head
	movzx	ecx, BYTE PTR [eax]
	movzx	edx, BYTE PTR _dir$[ebp]
	add	ecx, edx
	and	ecx, -2147483641			; 80000007H
	jns	SHORT $LN20@move
	dec	ecx
	or	ecx, -8					; fffffff8H
	inc	ecx
$LN20@move:
	mov	eax, DWORD PTR ?pivot@@3PAUNode@@A	; pivot
	mov	BYTE PTR [eax], cl
	mov	ecx, DWORD PTR ?head@@3PAUNode@@A	; head
	movzx	edx, BYTE PTR [ecx+1]
	movzx	eax, BYTE PTR _dir$[ebp+1]
	add	edx, eax
	and	edx, -2147483641			; 80000007H
	jns	SHORT $LN21@move
	dec	edx
	or	edx, -8					; fffffff8H
	inc	edx
$LN21@move:
	mov	ecx, DWORD PTR ?pivot@@3PAUNode@@A	; pivot
	mov	BYTE PTR [ecx+1], dl
	jmp	SHORT $LN2@move
$LN3@move:
	mov	edx, DWORD PTR _p$[ebp]
	cmp	edx, DWORD PTR ?head@@3PAUNode@@A	; head
	je	SHORT $LN2@move
	call	?lose@@YAXXZ				; lose
	jmp	SHORT $LN15@move
$LN2@move:
	mov	al, BYTE PTR _tdir$[ebp]
	mov	BYTE PTR ?idir@@3EA, al			; idir
	mov	ecx, DWORD PTR ?head@@3PAUNode@@A	; head
	mov	edx, DWORD PTR ?pivot@@3PAUNode@@A	; pivot
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR ?pivot@@3PAUNode@@A	; pivot
	mov	DWORD PTR ?head@@3PAUNode@@A, eax	; head
	mov	ecx, DWORD PTR ?pivot@@3PAUNode@@A	; pivot
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR ?pivot@@3PAUNode@@A, edx	; pivot
	mov	eax, DWORD PTR ?head@@3PAUNode@@A	; head
	mov	ecx, DWORD PTR ?pivot@@3PAUNode@@A	; pivot
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
$LN15@move:
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?move@@YAXE@Z ENDP					; move
_TEXT	ENDS
PUBLIC	?print@@YAXXZ					; print
; Function compile flags: /Odtp
_TEXT	SEGMENT
_j$ = -2						; size = 1
_i$ = -1						; size = 1
?print@@YAXXZ PROC					; print
	push	ebp
	mov	ebp, esp
	push	ecx
	call	?createGraph@@YAXXZ			; createGraph
	mov	BYTE PTR _i$[ebp], 0
	jmp	SHORT $LN6@print
$LN5@print:
	mov	al, BYTE PTR _i$[ebp]
	add	al, 1
	mov	BYTE PTR _i$[ebp], al
$LN6@print:
	movzx	ecx, BYTE PTR _i$[ebp]
	cmp	ecx, 8
	jge	SHORT $LN7@print
	mov	BYTE PTR _j$[ebp], 0
	jmp	SHORT $LN3@print
$LN2@print:
	mov	dl, BYTE PTR _j$[ebp]
	add	dl, 1
	mov	BYTE PTR _j$[ebp], dl
$LN3@print:
	movzx	eax, BYTE PTR _j$[ebp]
	cmp	eax, 8
	jge	SHORT $LN1@print
	jmp	SHORT $LN2@print
$LN1@print:
	jmp	SHORT $LN5@print
$LN7@print:
	mov	esp, ebp
	pop	ebp
	ret	0
?print@@YAXXZ ENDP					; print
_TEXT	ENDS
PUBLIC	?converToHex@@YAEE@Z				; converToHex
; Function compile flags: /Odtp
_TEXT	SEGMENT
_ch$ = 8						; size = 1
?converToHex@@YAEE@Z PROC				; converToHex
	push	ebp
	mov	ebp, esp
	movzx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, 9
	jg	SHORT $LN2@converToHe
	movzx	eax, BYTE PTR _ch$[ebp]
	add	eax, 48					; 00000030H
	jmp	SHORT $LN3@converToHe
	jmp	SHORT $LN3@converToHe
$LN2@converToHe:
	movzx	eax, BYTE PTR _ch$[ebp]
	add	eax, 55					; 00000037H
$LN3@converToHe:
	pop	ebp
	ret	0
?converToHex@@YAEE@Z ENDP				; converToHex
_TEXT	ENDS
PUBLIC	?createOutputData@@YAXXZ			; createOutputData
; Function compile flags: /Odtp
_TEXT	SEGMENT
_j$ = -2						; size = 1
_i$ = -1						; size = 1
?createOutputData@@YAXXZ PROC				; createOutputData
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	call	?createGraph@@YAXXZ			; createGraph
	mov	BYTE PTR _i$[ebp], 0
	jmp	SHORT $LN6@createOutp
$LN5@createOutp:
	mov	al, BYTE PTR _i$[ebp]
	add	al, 1
	mov	BYTE PTR _i$[ebp], al
$LN6@createOutp:
	movzx	ecx, BYTE PTR _i$[ebp]
	cmp	ecx, 8
	jge	SHORT $LN7@createOutp
	movzx	edx, BYTE PTR _i$[ebp]
	mov	BYTE PTR ?outputData@@3PAEA[edx], 0
	mov	BYTE PTR _j$[ebp], 0
	jmp	SHORT $LN3@createOutp
$LN2@createOutp:
	mov	al, BYTE PTR _j$[ebp]
	add	al, 1
	mov	BYTE PTR _j$[ebp], al
$LN3@createOutp:
	movzx	ecx, BYTE PTR _j$[ebp]
	cmp	ecx, 8
	jge	SHORT $LN1@createOutp
	movzx	edx, BYTE PTR _i$[ebp]
	mov	al, BYTE PTR ?outputData@@3PAEA[edx]
	shl	al, 1
	movzx	ecx, BYTE PTR _i$[ebp]
	mov	BYTE PTR ?outputData@@3PAEA[ecx], al
	movzx	edx, BYTE PTR _i$[ebp]
	movzx	eax, BYTE PTR _i$[ebp]
	movzx	ecx, BYTE PTR _j$[ebp]
	mov	esi, 7
	sub	esi, ecx
	movzx	eax, BYTE PTR ?graph@@3PAY07EA[esi+eax*8]
	neg	eax
	sbb	eax, eax
	neg	eax
	movzx	ecx, BYTE PTR ?outputData@@3PAEA[edx]
	add	ecx, eax
	movzx	edx, BYTE PTR _i$[ebp]
	mov	BYTE PTR ?outputData@@3PAEA[edx], cl
	jmp	SHORT $LN2@createOutp
$LN1@createOutp:
	jmp	$LN5@createOutp
$LN7@createOutp:
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?createOutputData@@YAXXZ ENDP				; createOutputData
_TEXT	ENDS
PUBLIC	?convert@@YAEE@Z				; convert
; Function compile flags: /Odtp
_TEXT	SEGMENT
tv65 = -4						; size = 4
_ch$ = 8						; size = 1
?convert@@YAEE@Z PROC					; convert
	push	ebp
	mov	ebp, esp
	push	ecx
	movzx	eax, BYTE PTR _ch$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	mov	ecx, DWORD PTR tv65[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv65[ebp], ecx
	cmp	DWORD PTR tv65[ebp], 4
	ja	SHORT $LN5@convert
	mov	edx, DWORD PTR tv65[ebp]
	jmp	DWORD PTR $LN9@convert[edx*4]
$LN4@convert:
	mov	al, 1
	jmp	SHORT $LN7@convert
$LN3@convert:
	mov	al, 4
	jmp	SHORT $LN7@convert
$LN2@convert:
	mov	al, 3
	jmp	SHORT $LN7@convert
$LN1@convert:
	mov	al, 2
	jmp	SHORT $LN7@convert
$LN5@convert:
	xor	al, al
$LN7@convert:
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN9@convert:
	DD	$LN4@convert
	DD	$LN3@convert
	DD	$LN2@convert
	DD	$LN5@convert
	DD	$LN1@convert
?convert@@YAEE@Z ENDP					; convert
_TEXT	ENDS
PUBLIC	_main
; Function compile flags: /Odtp
_TEXT	SEGMENT
_idir$ = -1						; size = 1
_main	PROC
	push	ebp
	mov	ebp, esp
	push	ecx
	push	1000					; 000003e8H
	call	?setSeed@@YAXH@Z			; setSeed
	add	esp, 4
	call	?init@@YAXXZ				; init
	mov	BYTE PTR _idir$[ebp], 0
$LN2@main:
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN1@main
	movzx	ecx, BYTE PTR _idir$[ebp]
	push	ecx
	call	?move@@YAXE@Z				; move
	add	esp, 4
	call	?print@@YAXXZ				; print
	call	?createOutputData@@YAXXZ		; createOutputData
	movzx	edx, BYTE PTR _idir$[ebp]
	sub	edx, 48					; 00000030H
	mov	BYTE PTR _idir$[ebp], dl
	movzx	eax, BYTE PTR _idir$[ebp]
	push	eax
	call	?convert@@YAEE@Z			; convert
	add	esp, 4
	mov	BYTE PTR _idir$[ebp], al
	jmp	SHORT $LN2@main
$LN1@main:
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
_main	ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??__Ean@@YAXXZ
text$yc	SEGMENT
??__Ean@@YAXXZ PROC					; `dynamic initializer for 'an'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ?c@@3HA			; c
	mov	DWORD PTR ?an@@3HA, eax			; an
	pop	ebp
	ret	0
??__Ean@@YAXXZ ENDP					; `dynamic initializer for 'an''
text$yc	ENDS
PUBLIC	?an@@3HA					; an
_BSS	SEGMENT
?an@@3HA DD	01H DUP (?)				; an
_BSS	ENDS
CRT$XCU	SEGMENT
_an$initializer$ DD FLAT:??__Ean@@YAXXZ
CRT$XCU	ENDS
END
